## courses

[opslss 2016](https://www.cs.uoregon.edu/research/summerschool/summer16/curriculum.php)

[opslss 2015](https://www.cs.uoregon.edu/research/summerschool/summer15/curriculum.html)

[opslss 2014](https://www.cs.uoregon.edu/research/summerschool/summer14/curriculum.html)

[opslss 2013](https://www.cs.uoregon.edu/research/summerschool/summer13/curriculum.html)

[opslss 2012](https://www.cs.uoregon.edu/research/summerschool/summer12/curriculum.html)

[Robert Harper's Homotopy type theory course at CMU](https://www.cs.cmu.edu/~rwh/courses/hott/)

[Computational (Higher) Type Theory tutorial - POPL 2018](https://existentialtype.wordpress.com/2018/01/15/popl-2018-tutorial/) [slides](http://www.cs.cmu.edu/~rwh/talks/POPL18-Tutorial.pdf)

[15-816 Linear Logic at CMU](http://www.cs.cmu.edu/~fp/courses/15816-s12/schedule.html) [reddit](https://www.reddit.com/r/haskell/comments/6s80zw/does_linear_typing_allow_you_to_infer_time_and/) [reddit2](https://www.reddit.com/r/haskell/comments/6sdwak/take_zip_an_issue_with_linear_streams/)

[15-816 Substructural Logics at CMU](http://www.cs.cmu.edu/~fp/courses/15816-f16/schedule.html)

[sywtltt](http://purelytheoretical.com/sywtltt.html)

[A Roadmap for Type Theory](https://www.reddit.com/r/types/comments/50x10v/request_a_roadmap_for_type_theory/)

[Lecturas del Grupo de Lógica Computacional](https://github.com/jaalonso/Lecturas_GLC)

[6.851: Advanced Data Structures (Fall'17)](http://courses.csail.mit.edu/6.851/fall17/lectures/)

[Programming Language Theory in Agda](https://wenkokke.github.io/sf/)

[lambdadays 2019](http://www.lambdadays.org/lambdadays2019)

[Robert Harper - Computational Type Theory](https://www.youtube.com/playlist?list=PL0DsGHMPLUWXXA8RHzVZ2B5E5hP8CD15Z)

[denotational semantics course](https://www.cl.cam.ac.uk/teaching/1920/DenotSem/)

[definitions as first-class citizens](https://twitter.com/PTOOP/status/1672996447141109761)

## videos

[Simon Peyton Jones - Compiling without continuations](https://www.youtube.com/watch?v=LMTr8yw0Gk4)

[Cubical adventures](https://www.youtube.com/watch?v=W5-ulP_JzNc)

### OPLSS 2012

[proofs as processes OPLSS 2012](https://www.youtube.com/watch?v=tlc-6b515xg)

### OPLSS 2013

[software foundations in coq OPLSS 2013](https://www.youtube.com/watch?v=KKrD4JcfW90)

[polarization and focalization OPLS 2013](https://www.youtube.com/watch?v=W_UKTpTxNxA&index=8&list=PL5wN76fTY0N4O7Q8FizzJk96-_CJzErcS)

### OPLSS 2014

[type theory foundations OPLSS 2014](https://www.youtube.com/watch?v=9SnefrwBIDc&list=PLGCr8P_YncjXRzdGq2SjKv5F2J8HUFeqN)

[category theory foundation OPLSS 2014](https://www.youtube.com/watch?v=BF6kHD1DAeU&list=PLGCr8P_YncjVjwAxrifKgcQYtbZ3zuPlb&index=1)

### OPLSS 2015

[introduction to dependent type theory OPLSS 2015](https://www.youtube.com/watch?v=y-lX1mx5_i0&list=PLt7hcIEdZLAnbUxKaG7XIynEWrozOBtXU)

[logical relations OPLSS 2015](https://www.youtube.com/watch?v=bio5BYECzF8&list=PLiHLLF-foEex7BOvMbrbUFC9XgU7fZW66)

[basic proof theory OPLSS 2015](https://www.youtube.com/watch?v=0zGPR5vTpeI&list=PLt7hcIEdZLAlY0oUz4VCQnF14C6VPtewG)

[The Coq Proof Assistant and Its Applications to Programming-Language Semantics — Adam Chlipala OPLSS 2015](https://www.youtube.com/watch?v=YM8uO6boCQc&list=PLt7hcIEdZLAnO7AawDQkHwE7RtwPDOFEc)

[Basic Category Theory: Semantics of Proof Theory — Ed Morehouse OPLSS 2015](https://www.cs.uoregon.edu/research/summerschool/summer15/curriculum.html)

[Inductive and Inductive-Recursive Definitions in Intuitionistic Type Theory — Peter Dybjer OPLSS 2015](https://www.youtube.com/watch?v=pK-lsJzi0ss&list=PLiHLLF-foEez0s9I8sFCdhQDLDzGmN_-q)

[proofs as processes OPLSS 2015](https://www.youtube.com/watch?v=OMzxl1c6pSo)

### OPLSS 2016

[Category Theory Background OPLSS 2016](https://www.youtube.com/watch?v=Fzw142d700A&list=PLiHLLF-foEexKDi7tmiO5tP8Uxt0ueK-L)

[Patricia Johann Lecture 1, OPLSS 2016 logical relations](https://www.youtube.com/watch?v=qUiA2MryBeo&list=PLiHLLF-foEeyC5w8uKLbbkuqEcLpMX2HB)

[Programming Languages Background — Robert Harper and Dan Licata OPLSS 2016 2016](https://www.youtube.com/watch?v=vK2T3qkg3sY&list=PLiHLLF-foEexkjDoPpVl8TV103TXoimf4)

[Network Programming — Nate Foster OPLSS 2016](https://www.youtube.com/watch?v=ipH9_tP-Apg&list=PLiHLLF-foEez7W9NkMCeFo2Tb1xRILsUs)

[Separation Logic and Concurrency — Aleks Nanevski OPLSS 2016](https://www.youtube.com/watch?v=ZmqvuxORL88&list=PLiHLLF-foEeyf7rtMFppo19f2egKqZGvC)

[Principles of Type Refinement — Noam Zeilberger OPLSS 2016](https://www.youtube.com/watch?v=lisnsULkfAo&list=PLiHLLF-foEeyS8V4lwN1qXRicRW0JCN2z)

[Logical relations/Compiler verification — Amal Ahmed OPLSS 2016](https://www.youtube.com/watch?v=vz5lDCFi2NE&list=PLiHLLF-foEexzqkMlTqzbbX_7V45MAXyX)

[Automated Complexity Analysis — Jan Hoffmann OPLSS 2016](https://www.youtube.com/watch?v=RQ2h5zrCQWk&list=PLiHLLF-foEexACltYKeaO-n7MR4VeTgK6)

### OPLSS 2018

[OPLSS 2018 - Algebraic Effects and Handlers - Andrej Bauer](https://www.youtube.com/watch?v=atYp386EGo8&list=PL0DsGHMPLUWX4YrLzwJGcqd-XsmXrE_Vn)

## ICFP

[ICFP](https://www.youtube.com/channel/UCwRL68qZFfub1Ep1EScfmBw) 

## ICFP 2016

[ICFP](https://www.youtube.com/channel/UCwRL68qZFfub1Ep1EScfmBw/playlists)

## ICFP 2018

[ICFP](https://icfp18.sigplan.org/track/icfp-2018-papers#event-overview) [reddit](https://www.reddit.com/r/haskell/comments/8k5i2h/icfp_2018_accepted_or_conditionally_accepted/)

## ICFP 2019

[ICFP 2019](https://www.youtube.com/playlist?list=PLU5vT1u6j4PfrKGZQKBybcLJ4dLC9w5VW)

## Scalaworld

[Scalaworld](https://www.youtube.com/channel/UCc0j7uOItUDh7vEvPb-TeCg/videos)

## Lambdaconf 2017

[156 videos](https://www.reddit.com/r/haskell/comments/77eea5/lambdaconf_2017_recorded_sessions_156_videos/)

## ICFP 2018

[ICFP 2018](https://etorreborre.blogspot.com/2018/09/icfp-2018.html)

[Capturing the Future by Replaying the Past](https://arxiv.org/pdf/1710.10385.pdf)

> Actually the authors of this paper show that mutable state + exceptions is all that is required to implement delimited continuations (except in C, read the paper for the details). There is a performance hit if we compare their implementation with a direct support from languages which support delimited continuations but this is not that bad.

[Versatile Event Correlation with Algebraic Effects](http://www.informatik.uni-marburg.de/~seba/publications/event-correlation-algebraic-effects.pdf)

> The paper shows that with a limited set of effects, like push but also trigger to trigger the materialization of a tuple or  get/set to temporarily store events, we can reproduce most of the behaviours exposed by so-called “complex event processing” (CEP) libraries: windowing, linear/affine consumption, zipping, and so on.

[Relational Algebra by Way of Adjunctions](http://www.cs.ox.ac.uk/jeremy.gibbons/publications/reladj-dbpl.pdf)

## POPL 2019

https://popl19.sigplan.org/track/POPL-2019-Research-Papers#event-overview

## Haskell eXchange 2018

[a well-typed binomial heap](https://skillsmatter.com/skillscasts/12386-a-well-typed-binomial-heap).

[write yourself a typed functional language](https://skillsmatter.com/skillscasts/12389-write-yourself-a-typed-functional-language).

[Dependent Types in Haskell](https://skillsmatter.com/skillscasts/12195-keynote-dependent-types-in-haskell)

> at 30:30 interesting dependent programming trick

> at 39:30, thoughts about the particularities of dependent types in #haskell

## ICFP 2019 Research Papers

[event overview](https://icfp19.sigplan.org/track/icfp-2019-papers#event-overview) 

[Proceedings of the ACM on Programming Languages Volume 3 Issue ICFP, August 2019](https://dl.acm.org/citation.cfm?id=3352468&preflayout=flat#prox)

## ICFP 2020 Research Papers

[papers](https://icfp20.sigplan.org/track/icfp-2020-papers#event-overview)

##  ICFP'20 

[playlist](https://www.youtube.com/watch?v=i9wgeX7e-nc&list=PLyrlk8Xaylp4fOgwO5RUTrpgSA_HRjDMW&index=3)

## CMU handouts

[CMU handouts](https://www.cs.cmu.edu/~fp/courses/comp-ded/handouts/)

## JFP

[Twice per year, JFP publishes the abstracts of recently completed PhD theses in the area of functional programming](https://www.cambridge.org/core/journals/journal-of-functional-programming/article/phd-abstracts/86D39E70D5D89E4C3E6D38434D10ADAC). [Type-Safe Generic Differencing of Mutually Recursive Families](https://twitter.com/etorreborre/status/1352915172311134211?s=03).

## ECOOP

[ECOOP'21](https://2021.ecoop.org/track/ecoop-2021-ecoop-research-papers#event-overview)

## ICFP 2021

[the list of accepted papers for ICFP '21](https://icfp21.sigplan.org/track/icfp-2021-papers#event-overview). [presentations](https://www.youtube.com/playlist?list=PLyrlk8Xaylp5ed_Yhg2oTdVhrtVohVaoa). 

## OPLS 2021

[list of lectures](https://www.youtube.com/playlist?list=PL0DsGHMPLUWXiPzmP9Ti2NVPcapIZETzQ). [RH talks about laziness in some of them](https://www.reddit.com/r/haskell/comments/otwo0a/principles_of_programming_languages_robert_harper/).

### Applied Category Theory 2021
[link](https://twitter.com/_julesh_/status/1421574078788407298)


### Others

[ICFP'22 Accepted Papers](https://twitter.com/icfp_conference/status/1545340265267081216)

[Recording of @Huawei Software Summit](https://twitter.com/danghica/status/1545395721477804033). [Huaweii, String Diagrams, Game Semantics](https://www.typetheoryforall.com/2022/06/27/20-Dan-Ghica.html#db051c43)

##

[SAT/SMT Solving](http://cl-informatik.uibk.ac.at/teaching/ss18/satsmt/content.php)

[formal reasoning about programs 2018](https://frap.csail.mit.edu/main)

## posts

[Call-By-Name, Call-By-Value and the λ-Calculus](https://www.reddit.com/r/haskell/comments/51js9s/understanding_plotkins_callbyname_callbyvalue_and/)

[hott stuff](https://www.reddit.com/r/haskell/comments/516htg/learning_haskell_as_a_category_theorist/d79qt3j)

[the three projections of doctor Futamura](http://blog.sigfpe.com/2009/05/three-projections-of-doctor-futamura.html)

[Random access lists, nested data types and numeral systems](http://hal2016.haskell.org/program.html#komuves)

[Papers We Love: John Reynolds, Definitional Interpreters for Higher-Order Programming Languages](http://wadler.blogspot.com.es/2016/06/papers-we-love-john-reynolds_10.html) [video](https://skillsmatter.com/skillscasts/8261-papers-we-love-meetup)

[Fold and unfold for program semantics](http://www.cs.nott.ac.uk/~pszgmh/semantics.pdf)

[type inference in stack based languages](https://www.reddit.com/r/haskell/comments/5yukuo/type_inference_in_stackbased_programming_languages/)

[recursion continuation trampolines](On Recursion, Continuations and Trampolines)

[system T interpreter](https://pay.reddit.com/r/haskell/comments/65t0t5/system_t_interpreter/)

[Simply Easy!](https://www.reddit.com/r/programming/comments/5ytek/simply_easy_an_implementation_of_a_dependently/c02aj2e/)

[logical relation](https://ncatlab.org/nlab/show/logical+relation) [slides](http://www.cs.le.ac.uk/people/amurawski/mgs12/part1.pdf)

[What are the differences between logical relations and simulations?](https://cstheory.stackexchange.com/questions/5427/what-are-the-differences-between-logical-relations-and-simulations)

[Hackett - type systems as macros](https://pay.reddit.com/r/haskell/comments/6dqf1n/realizing_hackett_a_metaprogrammable_haskell/)

[Search-based compiler code generation](http://jamey.thesharps.us/2017/06/search-based-compiler-code-generation.html)

[A Tutorial on Implementing Higher-Order Unification in Haskell](https://www.reddit.com/r/haskell/comments/6rs1bp/a_tutorial_on_implementing_higherorder/) [Follow-up](https://fineshambles.com/2017/07/26/a-type-inference-implementation-adventure/)

[What are the differences between logical relations and simulations?](https://cstheory.stackexchange.com/questions/5427/what-are-the-differences-between-logical-relations-and-simulations)

[Logical Frameworks and Meta-Languages: Theory and Practice](http://lfmtp.org/workshops/2017/program.shtml)

[Workshop on Homotopy Type Theory/ Univalent Foundations](https://hott-uf.github.io/2017/)

[Resources for writing a type checker?](https://www.reddit.com/r/haskell/comments/89pu1m/resources_for_writing_a_type_checker/) [mpre](https://www.reddit.com/r/haskell/comments/8fdbg6/background_knowledge_sources_for_writing_a_type/)

[Algorithmically Scrapping Your Typeclasses](http://reasonablypolymorphic.com/blog/algorithmic-sytc)

> infer is implemented as a catamorphism, which generates a fresh type variable for every node in the expression tree, looks up free variables in the SymTable and attempts to unify as it goes.

[Abstract interpretation](https://en.wikipedia.org/wiki/Abstract_interpretation)

[Is there any reason to compile pure lambda calculus with CPS?](https://www.reddit.com/r/haskell/comments/8fqel5/is_there_any_reason_to_compile_pure_lambda/)

> The alternative to cps from the "compiling without continuous" paper is "administrative normal form". There's an explication in the paper "the essence of continuations passing style", but the paper is pretty dense.

> Appel’s CPS implementation for ML is all the things he mentions: It’s rather large, it’s quite rigid, and it’s a pain to debug. An answer to this is Join Points, another is a Sea of Nodes. There, let-floating is a function of the scheduler and subsequent dead argument elimination passes. Additionally, the graph is naturally scheduled in data-dependence order but that is strictly not a requirement.

[A Graph-Based Higher-Order Intermediate Representation (Sea of nodes)](http://compilers.cs.uni-saarland.de/papers/lkh15_cgo.pdf)

[The Left Hand of Equals](http://lambda-the-ultimate.org/node/5509) [HN](https://news.ycombinator.com/item?id=17277169) [pdf](http://web.cecs.pdx.edu/~black/publications/egal.pdf)

[Type Theory Question](https://www.reddit.com/r/haskell/comments/924zwe/type_theory_question/)

[An Adequacy Theorem for Dependent Type Theory](https://link.springer.com/article/10.1007/s00224-018-9879-9)

[Old neglected theorems are still theorems](https://existentialtype.wordpress.com/2014/03/20/old-neglected-theorems-are-still-theorems/) [HN](https://news.ycombinator.com/item?id=12646390) [tweet](https://twitter.com/pigworker/status/1028283274165215237) [idris forum](https://groups.google.com/forum/#!msg/idris-lang/pLEkAiXDWHI/WMhG-zpFKhgJ)

[the abstract algorithm](https://www.reddit.com/r/haskell/comments/97lu10/functions_may_behave_as_if_they_had_negative/) [more](https://www.reddit.com/r/haskell/comments/97yj9f/explaining_the_unintuitive_performance_results/) [Optimality and inefficiency: what isn't a cost model of the lambda calculus?](https://dl.acm.org/citation.cfm?doid=232627.232639)

> Unfortunately, the bookkeeping to maintain the redex sharing takes exponential time

[how to implement system F-omega?](https://www.reddit.com/r/haskell/comments/9bveu0/monthly_hask_anything_september_2018/e6b8j2r)

[The AST Typing Problem](http://lambda-the-ultimate.org/node/4170).

> It is indeed quite common during compilation to repeatedly traverse an
AST doing operations only on some of its nodes (distinguished by a
type or a particular data constructor). That's why compiler
construction has been not only the biggest consumer for generic
programming libraries but also a notable producer.

[Why I no longer believe in computational classical type theory](https://queuea9.wordpress.com/2018/10/17/why-i-no-longer-believe-in-computational-classical-type-theory/). [A formulae-as-type notion of control](https://dl.acm.org/citation.cfm?id=96714). [reddit](https://www.reddit.com/r/haskell/comments/afckoe/why_i_no_longer_believe_in_computational/).

[Survey on Bidirectional Typechecking](https://semantic-domain.blogspot.com/2019/08/new-draft-paper-survey-on-bidirectional.html)

[musing on bidirectional typechecking](https://twitter.com/GabriellaG439/status/1557532060796891136). [more musings](https://twitter.com/GabriellaG439/status/1558104139317387264)

[What constitutes denotational semantics?](https://cstheory.stackexchange.com/questions/3577/what-constitutes-denotational-semantics) [Denotational semantics](https://en.wikipedia.org/wiki/Denotational_semantics). [tweet](https://twitter.com/_julesh_/status/1239198385019682822).

> In a parallel (concurrent) language, it is possible to short-circuit both sides: they are evaluated in parallel, and if one terminates with value true, the other is interrupted. This operator is thus called the parallel or.

> The problem of full abstraction for the sequential programming language PCF was, for a long time, a big open question in denotational semantics. The difficulty with PCF is that it is a very sequential language. For example, there is no way to define the parallel-or function in PCF. It is for this reason that the approach using domains, as introduced above, yields a denotational semantics that is not fully abstract.

> However, compositional semantic definitions have been losing their edge over the years. Robin Milner and Andy Pitts have developed a number of "operational reasoning" techniques, which work purely on the syntax but using the operational semantics wherever needed for talking about behaviour. These operational reasoning techniques are low-tech. No fancy mathematics. No infinite objects. We can teach them to undergraduates and anybody can use them. So, many people ask the question why we need denotational semantics at all.

> Operational approaches also score brilliantly when the programming languages get very fancy, with all kinds of loopy higher-order types. We may have no idea how to model such things mathematically. Or, the standard mathematical models might turn out to be inconsistent under the stress of loopiness. (For example, see "Polymorphism is not set-theoretic" by Reynolds.) Operational approaches that work purely on syntax can neatly side step all these mathematical problems.

> Another word about "operational semantics". In the early days, the term "operational" was used to refer to any semantic definition that referred to detailed evaluation steps. Both denotational semanticists and axiomatic proponents looked down upon "operational" semantics, regarding it as being low-level and machine-oriented. I think this was really based on their belief that higher level descriptions were possible. These beliefs were shattered as soon as they considered concurrency.

> Here we see the authors struggling with the two notions of "operational", one the technical notion - behaviour expressed using syntactic manipulations, and the other, the conceptual notion - being low-level and detailed. The credit largely goes to Plotkin and Milner for rehabilitating "operational" semantics, making it as high-level as possible and showing that it could be elegant and insightful.

> Despite all this, the operational notion of process is still quite different from the denotational notion of process, the latter of which was developed by both de Bakker and Hoare and their teams. And, I think there is a lot that is mysterious and beautiful about the denotational process concept which is still to be understood.

[tweet about unification](https://twitter.com/brendanzab/status/1316936871688212480)

[Don’t Think, Just Defunctionalize](https://news.ycombinator.com/item?id=25505701).

[forall / exists](https://www.reddit.com/r/haskell/comments/la2plt/richard_eisenberg_update_on_dependent_haskell/glnn1dx/)

[elaborate Reddit comment about evaluation strategies induction laziness and other stuff](https://www.reddit.com/r/haskell/comments/otwo0a/principles_of_programming_languages_robert_harper/)

[Introduction to Univalent Foundations of Mathematics with Agda](https://twitter.com/EscardoMartin/status/1431692062429261827)

# papers

[Linear types can change the world](http://eli.thegreenplace.net/2017/on-recursion-continuations-and-trampolines/)

[Do Be Do Be Do](https://pay.reddit.com/r/haskell/comments/5jxca8/do_be_do_be_do_frank_lambda_the_ultimate/)

[Polarized Data Parallel Data Flow](http://benl.ouroborus.net/papers/2016-polarized/dpdf-FHPC2016-preprint.pdf) [from](https://ghc.haskell.org/trac/ghc/wiki/LinearTypes/Examples)

[About the efficient reduction of lambda terms](https://arxiv.org/abs/1701.04240)

[Algebraic subtyping](https://www.cl.cam.ac.uk/~sd601/thesis.pdf)

[OutsideIn(X) Modular type inference with local assumptions](https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/jfp-outsidein.pdf) [reddit](https://www.reddit.com/r/haskell/comments/6fj21f/favorite_haskell_papers/dij9vds/)

[LCF considered as a programming language](http://www.sciencedirect.com/science/article/pii/0304397577900445)

[reddit comment](https://www.reddit.com/r/haskell/comments/5zvkq4/question_about_evaluation_strategies_and_linear/df1ocdf/) mentioning [On the unity of duality](http://noamz.org/papers/unity-duality.pdf) and [Least and Greatest Fixed Points in Linear Logic](http://www.lsv.fr/Publis/PAPERS/PDF/baelde12tocl.pdf).

[Abstract λ-Calculus Machines](http://www.informatik.uni-kiel.de/~wk/springer.pdf)

[Type systems for programming languages](http://gallium.inria.fr/~remy/mpri/cours3.pdf)

[Light Affine Lambda Calculus and Polynomial Time Strong Normalization](http://www.kurims.kyoto-u.ac.jp/~terui/lalcjournal.pdf)

[Linear types and non-size-increasing polynomial time computation](http://www.cs.cmu.edu/~fp/courses/15816-s12/misc/hofmann03ic.pdf)

[A Syntactical Analysis of Non-Size-Increasing Polynomial Time Computation](http://www.cs.cmu.edu/~fp/courses/15816-s12/misc/aehlig02tocl.pdf)

[Higher Inductive Types in Programming](http://www.cs.ru.nl/~herman/PUBS/HIT-programming.pdf)

[On Understanding Types,Data Abstraction, and Polymorphism](http://web.cse.ohio-state.edu/~soundarajan.1/courses/788/cardelli85understanding.pdf)

[Practical type inference for arbitrary-rank types](https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/putting.pdf) also [unification-fd](http://hackage.haskell.org/package/unification-fd) and [typing haskell in slightly more modern haskell](https://github.com/sinelaw/fresh/blob/thih/Main.hs) and this [tweet](https://twitter.com/noam_lewis/status/719407736623140865)

[Logic Programming and Type Inference with the Calculus of Constructions - Matthew Mirman](https://www.reddit.com/r/dependent_types/comments/623yd0/logic_programming_and_type_inference_with_the/)

[Comparing Ob ject Encodings](https://pdfs.semanticscholar.org/2551/2d30aec9a79ba91da67131298d3efa388108.pdf)

[Pi for all](https://github.com/sweirich/pi-forall)

[Logical Relations and Parametricity - A Reynolds Programme for Category Theory and Programming Languages](http://www.cs.bham.ac.uk/~udr/papers/logical-relations-and-parametricity.pdf)

[Logical Bisimulations and functional languages?](http://www.cs.unibo.it/~sangio/DOC_public/logBis.pdf)

[A Logical Relation for Monadic Encapsulation of State](http://iris-project.org/pdfs/runST.pdf)

[stack safety for free](http://functorial.com/stack-safety-for-free/index.pdf)

[Incremental Parametric Syntax for Multi-Language Transformation](https://arxiv.org/pdf/1707.04600.pdf)

[popl2018-papers](https://github.com/gasche/popl2018-papers)

[Sound and Complete Bidirectional Typechecking for Higher-Rank Polymorphism with Existentials and Indexed Types](https://arxiv.org/abs/1601.05106) [reddit](https://www.reddit.com/r/haskell/comments/7nmcrj/what_evaluation_strategy_to_use_for_a_new/)

[The Calculus of Dependent Lambda Eliminations](http://homepage.divms.uiowa.edu/~astump/papers/cdle.pdf) [so](https://stackoverflow.com/a/48234737/1364288)

> Lambda encodings were abandoned as a basis for constructive type theory almost thirty years ago

> Induction principles are not derivable for lambda encodings (Geuvers, 2001)

[Induction Is Not Derivable in Second Order Dependent Type Theory](https://link.springer.com/chapter/10.1007/3-540-45413-6_16) [reddit](https://www.reddit.com/r/dependent_types/comments/a1fsu/induction_is_not_derivable_in_second_order/)

> We give counter-models in which the induction principle over natural numbers is not valid.

[Compiling with Continuations, Continued](https://pdfs.semanticscholar.org/d579/1235ad4439f48fcdd359d45d144ee6a23ac9.pdf)

[The essence of compiling with continuations](https://slang.soe.ucsc.edu/cormac/papers/pldi93.pdf)

[Compiling without continuations](https://www.microsoft.com/en-us/research/wp-content/uploads/2016/11/join-points.pdf)

> The case-of-case transformation, including the idea of using let bindings to avoid duplication, is very old

[Declarative semantics for functional languages: compositional, extensional, and elementary](https://arxiv.org/pdf/1707.03762.pdf) [reddit](https://www.reddit.com/r/haskell/comments/6plx71/declarative_semantics_for_functional_languages/)

[An Introduction to Logical Relations](https://www.cs.uoregon.edu/research/summerschool/summer16/notes/AhmedLR.pdf)

[Complete and Easy Bidirectional Typechecking for Higher-Rank Polymorphism](https://www.cl.cam.ac.uk/~nk480/bidir.pdf) apparently v good [slides](http://www.cs.cmu.edu/~joshuad/talks/icfp13/Dunfield_icfp13-talk.pdf)

[A Short Introduction to Systems F and Fω](http://babel.ls.fi.upm.es/~pablo/Papers/Notes/f-fw.pdf)

[Practical type inference for arbitrary-rank types](https://www.microsoft.com/en-us/research/publication/practical-type-inference-for-arbitrary-rank-types/)

[Boxy type inference for higher-rank types and impredicativity](https://www.microsoft.com/en-us/research/publication/boxy-type-inference-for-higher-rank-types-and-impredicativity/) watch out, impredicativity!

[Formalized Unification Algorithms](http://www2.imm.dtu.dk/pubdb/views/edoc_download.php/7094/pdf/imm7094.pdf)

[Overlapping and Order-Independent Patterns](https://pdfs.semanticscholar.org/9cde/3b72487718f810abb0cc468f0166643d5119.pdf)

[Compilation as a Typed EDSL-to-EDSL Transformation](https://arxiv.org/html/1603.08865) [reddit](https://www.reddit.com/r/haskell/comments/8ddfoi/compilation_as_a_typed_edsltoedsl_transformation/)

[Stitch: The Sound Type-Indexed Type Checker](https://cs.brynmawr.edu/~rae/papers/2018/stitch/stitch.pdf)

> all this shifting can slow the interpreter
down. A variable shift requires a full traversal and rebuild of the AST, costing precious time
and allocations. Though I have not done it in my implementation, it would be possible to add
a Shift constructor to the AST type to allow these shifts to be lazily evaluated; the design and
implementation of other opportunities for optimization is left as future work.

[How to Architect a Query Compiler](https://dl.acm.org/citation.cfm?id=2915244) [pdf](https://infoscience.epfl.ch/record/218087/files/how-to-architect-a-query-compiler.pdf)

[Abstract Interpretation, Logical Relations, and Kan Extensions](https://academic.oup.com/logcom/article-abstract/1/1/5/948914?redirectedFrom=fulltext)

[TLA+ in Practice and Theory Part 4: Order in TLA+](https://pron.github.io/posts/tlaplus_part4)

> Galois connections serve as the basis for abstract interpretation, a central concept in the theory of program analysis, developed by Patrick and Radhia Cousot in the 1970s. In TLA terms, abstract interpretation is a process by which the more abstract specification, G
, is automatically generated from the more concrete one, F. Abstract interpretation places different kinds of programs semantics on a spectrum of abstraction, from behaviors to functional denotational semantics. Many ideas in program analysis, including type checking, model checking and deductive proofs can all be viewed as forms of abstract interpretation. In TLA+ this idea is made explicit and formally manipulable, though less general.

[Logical Full Abstraction and PCF](http://homepages.inf.ed.ac.uk/gdp/publications/Log_Full_Abs.pdf)

[Definability and Full Abstraction](https://ac.els-cdn.com/S1571066107000837/1-s2.0-S1571066107000837-main.pdf?_tid=c0459fb9-4aa8-447f-8990-68ab34cd6774&acdnat=1524352529_bb1104cabebd3a078fe3296f64b021ed)

[Abstract Interpretation - a semantics-based tool for program analysis](http://www.cs.umd.edu/class/fall2014/cmsc631/papers/jones-ai-tutorial.pdf)

[Traits: Composable Units of Behaviour](http://scg.unibe.ch/archive/papers/Scha03aTraits.pdf)

[Literature Review of GHC Core](https://github.com/xnning/GHC-Core-Literature-Review/blob/master/doc/doc.pdf) [reddit](https://www.reddit.com/r/haskell/comments/8u4h5i/literature_review_of_ghc_core/)

[Coercions for Dummies](http://reasonablypolymorphic.com/blog/roles/) [reddit](https://www.reddit.com/r/haskell/comments/8tyccn/coercions_and_roles_for_dummies_reasonably/)

[10 papers that all PhD students in programming languages ought to know, for some value of 10](https://github.com/nuprl/10PL)

[Light Affine Set Theory: A Naive Set Theory of Polynomial Time](http://www.kurims.kyoto-u.ac.jp/~terui/lastfin.pdf) [twitter](https://twitter.com/fabgenovese/status/1023714144942542849)

[Elaborating Dependent (Co)pattern Matching](https://dl.acm.org/citation.cfm?id=3236770)

[A Metalanguage for Guarded Iteration](https://arxiv.org/abs/1807.11256)

[Coherent Explicit Dictionary Application for Haskell: Formalisation and Coherence Proof](https://arxiv.org/abs/1807.11267)

[Partially-Static Data as Free Extension of Algebras](https://dl.acm.org/citation.cfm?id=3236795)

[From algebra to abstract machine: a verified generic construction](http://www.staff.science.uu.nl/~swier004/publications/2018-tyde.pdf)

[Connot McBride on total languages - Turing-Completeness Totally Free](https://personal.cis.strath.ac.uk/conor.mcbride/TotallyFree.pdf) [Datatypes of Datatypes](https://www.cs.ox.ac.uk/projects/utgp/school/conor.pdf) [tweet](https://twitter.com/pigworker/status/1028793281843486725) [tweet](https://twitter.com/pigworker/status/566707499290857472) [tweet](https://twitter.com/pigworker/status/699259807157587968) [tweet](https://twitter.com/pigworker/status/1028906581688299520) [tweet](https://twitter.com/pigworker/status/1028893107876765696) [hasochistic containers](https://www.reddit.com/r/haskell/comments/38wels/conor_mcbride_hasochistic_containers/) [event](https://www.nottingham.ac.uk/computerscience/events/totality-versus-turing-completeness.aspx)

> When we put that "Delay" in the type, or write a fuel-driven approximant, we're often accused of somehow cheating, but we're only telling the truth: we can't show this is finite but we can run it as long as you want.

[basics of bidirectionalism](https://pigworker.wordpress.com/2018/08/06/basics-of-bidirectionalism/) [lobsters](https://lobste.rs/s/xwsgq1/basics_bidirectionalism). [a quick look at impredicativity](https://www.microsoft.com/en-us/research/publication/a-quick-look-at-impredicativity/). [video](https://www.youtube.com/watch?v=ZuNMo136QqI)

[Freer monads, more extensible effects](http://okmij.org/ftp/Haskell/extensible/more.pdf) [video](https://www.youtube.com/watch?v=3Ltgkjpme-Y). [Free and Freer Monads: Putting Monads Back into Closet](http://okmij.org/ftp/Computation/free-monad.html). [slides](http://lambdafoo.com/fp-syd-freer-2016/#1). [What is your opinion on Eff vs. mtl-style design?](https://www.reddit.com/r/purescript/comments/5wwyww/what_is_your_opinion_on_eff_vs_mtlstyle_design/). [How do I compose 'freer' effects in haskell?](https://www.reddit.com/r/purescript/comments/5wwyww/what_is_your_opinion_on_eff_vs_mtlstyle_design/). [One Monad to Prove Them All](https://arxiv.org/pdf/1805.08059.pdf). see also the algebraic effects and handlers videos from OPLSS 2018.

> Writing Monad (and now, Applicative and Functor) instances and making sure the monad laws hold are a big part of defining a monad and even a bigger part in exponentially procreating monad tutorials. We argue that all these instances are boilerplate -- avoidable boilerplate. Perhaps because of the Latin-sounding names and the evocation of the highest Math, the petty boilerplate, trivial laws, plain old plumbing have usurped an extraordinary amount of attention. Wouldn't it be refreshing if we could directly think on what an effect does rather than on how the plumbing works.

[The Calculus of Dependent Lambda Eliminations](http://homepage.divms.uiowa.edu/~astump/papers/cdle.pdf)

> Modern constructive type theory is based on pure dependently typed lambda calculus, augmented
with user-defined datatypes. This paper presents an alternative called the Calculus of Dependent
Lambda Eliminations, based on pure lambda encodings with no auxiliary datatype system.

> Lambda encodings were abandoned as a basis for constructive type
theory almost thirty years ago, due to the following problems

[Univalent Foundations and the UniMath Library](http://philsci-archive.pitt.edu/15034/1/Univalent_Foundations_and_the_UniMath_library.pdf)

> the idea of higher inductive types being that unlike ordinary inductive types we allow in
their definitions not only constructors that generate elements of the type being defined,
but also constructors that generate paths (i.e. elements of identity types) or even higher
homotopies.

[Theory and practice of demand analysis in Haskell](https://www.microsoft.com/en-us/research/publication/theory-practice-demand-analysis-haskell/).

[cubical Agda](https://homotopytypetheory.org/2018/12/06/cubical-agda/). [On Higher Inductive Types in Cubical Type Theory](https://arxiv.org/abs/1802.01170).

[A Verified Compiler for a Linear Imperative/Functional Intermediate Language](https://www.ps.uni-saarland.de/Publications/documents/Schneider_2018_PhDThesis.pdf)

[Signatures and Induction Principles for Higher Inductive-Inductive Types](https://arxiv.org/abs/1902.00297).

[Stochastic Lambda Calculus and Monads of Probability Distributions](https://www.cs.tufts.edu/~nr/pubs/pmonad.pdf)

[A Probabilistic Language based upon Sampling Functions](https://www.cs.cmu.edu/~fp/papers/popl05.pdf)

[Effect Handlers via Generalised Continuations](https://bentnib.org/handlers-cps-journal.html).

[Definitional Proof-Irrelevance without K](https://popl19.sigplan.org/event/popl-2019-research-papers-definitional-proof-irrelevance-without-k). [video](https://www.youtube.com/watch?v=G6adbrpaecY).

> Definitional equality—or conversion—for a type theory with a decidable type checking is the simplest tool to prove that two objects are the same, letting the system decide just using computation. Therefore, the more things are equal by conversion, the simpler it is to use a language based on type theory. 

[Infinite Types, Infinite Data, Infinite Interaction](https://arxiv.org/abs/1902.10971).

[From Parametricity to Conservation Laws, via Noether's Theorem](https://bentnib.org/conservation-laws.html)

[Higher-order Type-level Programming in Haskell](https://www.microsoft.com/en-us/research/uploads/prod/2019/03/ho-haskell.pdf).

[Kinds are calling conventions](https://www.microsoft.com/en-us/research/uploads/prod/2019/03/eta.pdf)

[Partial Type Constructors (extended version)](https://cs.brynmawr.edu/~rae/papers/2019/partialdata/partialdata.pdf).

[System Fω and Parameterization](https://blog.jez.io/system-f-param/). [reddit](https://www.reddit.com/r/haskell/comments/b7kpld/system_f%CF%89_and_parameterization/).

[Symbolic Execution is a case of Abstract Interpretation?](https://cstheory.stackexchange.com/questions/19708/symbolic-execution-is-a-case-of-abstract-interpretation). [HN](https://news.ycombinator.com/item?id=19605761). [Meta-circular Abstract Interpretation in Prolog](http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.137.3604).

[Call-By-Need is Clairvoyant Call-By-Value](http://www.cs.nott.ac.uk/~pszgmh/clairvoyant.pdf).

[Quantitative Program Reasoning with Graded Modal Types](https://www.cs.kent.ac.uk/people/staff/dao7/publ/granule-icfp19.pdf). [Granule](https://twitter.com/dorchard/status/1143879816535597058).

[Domain-Aware Session Types](https://arxiv.org/abs/1907.01318)

[Recovering Purity with Comonads and Capabilities](http://semantic-domain.blogspot.com/2019/07/all-comonads-all-time.html)

[Julia’s Efficient Algorithm for Subtyping Unions and Covariant Tuples](http://drops.dagstuhl.de/opus/volltexte/2019/10816/pdf/LIPIcs-ECOOP-2019-24.pdf)

[A Predicate Transformer Semantics for Effects](http://www.staff.science.uu.nl/~swier004/publications/2019-icfp-tim.pdf)

[kind inference for datatypes](https://www.reddit.com/r/haskell/comments/cf9yxc/kind_inference_for_datatypes_pdf/)

[Checking Dependent Types with ormalization by Evaluation: A Tutorial (Haskell Version)](http://davidchristiansen.dk/tutorials/implementing-types-hs.pdf). [tweet](https://twitter.com/d_christiansen/status/1156227122387492864).

[The futamura projections](https://twitter.com/DiazCarrete/status/1173661122001588224)

[A tiny implementation of GHC's OutsideIn(X) algorithm.](https://twitter.com/smdiehl/status/1176126290199556096)

[A Modular Inference of Linear Types for Multiplicity-Annotated Arrows](https://arxiv.org/pdf/1911.00268.pdf)

[runners in action](https://arxiv.org/abs/1910.11629). [post](http://math.andrej.com/2019/10/28/runners-in-action/). [repo](https://twitter.com/scottfleischman/status/1188949672385056769). [Interacting with external resources
using runners (aka comodels)](https://danel.ahman.ee/talks/chocola19.pdf)

> We shall address these kinds of issues indirectly (!), by not introducing a linear typing discipline‚ but instead we make it convenient to hide external resources

[Dependently typed lambda calculus with a lifting operator](https://www-sop.inria.fr/members/Damien.Rouhling/data/internships/M1Report.pdf). [tweet](https://twitter.com/brendanzab/status/1212624986675924994).

[Defunctionalization: Everybody Does It, Nobody Talks About It](https://blog.sigplan.org/2019/12/30/defunctionalization-everybody-does-it-nobody-talks-about-it/). [Defunctionalisation: An underappreciated tool for writing good software](https://www.gresearch.co.uk/article/defunctionalisation/). [hn](https://news.ycombinator.com/item?id=22525038).

[on recursion continuations and trampolines](https://www.reddit.com/r/programming/comments/fp6y66/on_recursion_continuations_and_trampolines/)

[LoCal: A Language for Programs Operating on Serialized Data](http://recurial.com/pldi19main.pdf)

[Generalized Monoidal Effects And Handlers](https://rubenpieters.github.io/assets/papers/JFP20-handlers.pdf)

[Lower Your Guards](https://www.microsoft.com/en-us/research/uploads/prod/2020/03/lyg.pdf)

[Elaborating dependent (co)pattern matching](https://dl.acm.org/doi/10.1145/3236770)

[Type Inference from Scratch](https://www.youtube.com/watch?v=frM7GhBERAs&feature=youtu.be)

[Programming Languages as Objects in Nature](https://parentheticallyspeaking.org/articles/pls-nature/). [tweet](https://twitter.com/ShriramKMurthi/status/1282098772328230912). [The Next 700 Semantics](https://cs.brown.edu/~sk/Publications/Papers/Published/kle-next-700-semantics//)

[Lambda encodings were abandoned as a basis for constructive type theory almost thirty years ago, due to the following problems](https://homepage.cs.uiowa.edu/~astump//papers/cedille-draft.pdf). [Induction Is Not Derivable in Second Order Dependent Type Theory](https://link.springer.com/chapter/10.1007/3-540-45413-6_16). [Something is lost when we encode data or codata impredicatively. Lambda is not the Ultimate.](https://www.reddit.com/r/dependent_types/comments/a1fsu/induction_is_not_derivable_in_second_order/c0fg4nh/). [in type theory this definition of the recursion scheme suffers from same inefficiency as plagues the predecessor for Church-encoded naturals](https://arxiv.org/pdf/2001.02828.pdf)

tweets about Facet https://twitter.com/rob_rix/status/1320544724864872453 https://twitter.com/rob_rix/status/1318518708059492353 telescopes https://twitter.com/rob_rix/status/1320381469769011202 https://twitter.com/rob_rix/status/1320695095268675584

[Dijkstra Monads Forever: Termination-Sensitive Specifications for Interaction Trees](https://www.seas.upenn.edu/~lucsil/papers/dmf.pdf)

> We model such programs using interaction trees, a coinductive datatype for representing programs with algebraic effects

[A graded dependent type system with a usage-aware semantics ](https://arxiv.org/abs/2011.04070). [video](https://www.youtube.com/watch?v=zglkdlK2zR8).

[Design and Implementation of Effect Handlers for Object-Oriented Programming Languages](https://www.cambridge.org/core/journals/journal-of-functional-programming/article/phd-abstracts/86D39E70D5D89E4C3E6D38434D10ADAC)

> Our design employs explicit capability-passing style.
That is, instead of dynamically searching for a handler at runtime, we pass instances of
handlers as additional arguments to methods.

[Handling Local State with Global State](https://people.cs.kuleuven.be/~tom.schrijvers/Research/papers/mpc2019.pdf)

[Programming, Logic and Semantics Lab](https://www.pls-lab.org/). [tweet](https://twitter.com/laMudri/status/1365805874464382984).

[closure conversion is safe for space](https://twitter.com/andywingo/status/1379360000963981317)

[Apparently it's way easier to write a staged interpreter than it is to write a compiler pass; functional IRs get their revenge!](https://twitter.com/ezyang/status/1381681218035539973)

[Cheap interpreter, part 7: register machines](https://cuddly-octo-palm-tree.com/posts/2021-08-01-cwafi-7-register-machine/)

[Computational duality and the sequent calculus](https://ix.cs.uoregon.edu/~pdownen/publications/cdsc.pdf). [tweet](https://twitter.com/rob_rix/status/1437740717686722560).

[Resources on Algorithm W](https://www.reddit.com/r/haskell/comments/s5cnld/hindleymilner_type_interference/). [OutsideIn](https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/jfp-outsidein.pdf).  [the french approach to type inference](http://gallium.inria.fr/~fpottier/publis/emlti-final.pdf).

> "Typing Haskell in Haskell" by Mark P. Jones is substitution-based, but quite detailed and also deals with inference for haskell-style type classes.

> "Hindley-Milner style type systems in constraint form" by Sulzmann, Müller, and Zenger may be what you're looking for, as its typing rules accumulate a set of constraints as they go.

> "Proofs about a Folklore Let-Polymorphic Type Inference Algorithm" by Oukseh Lee and Kwangkeun Yi might also be interesting. It's about both Algorithm W, which builds a substitution in a bottom-up manner, as well as its "opposite": Algorithm M, which pushes constraints through the term in a top-down manner.

> You might find "Type Inference by Solving Constraints" by Caleb Helbling useful. The blog itself vanished in 2019, but the Internet Archive still had a copy here with working code snippets.

> Lecture 19: Type Inference of "Programming and Programming Languages" (link) details what constraints to generate and how to solve them, though the programming language used is unfamiliar to me.

[the untyped lambda calculus yay or nay](https://twitter.com/ezyang/status/1481831674811985924?s=03)

["the best explantion of unification"](https://twitter.com/haskellhutt/status/1484905439435403267)

[Implementing Hindley-Milner with the unification-fd library](https://twitter.com/Jose_A_Alonso/status/1436449406522302468)

[the hardest part of implementing a type system is unification](https://twitter.com/GabriellaG439/status/1484764412976123904)

> I think unification by itself is OK, it's the lumping it all together that
> bugs me. I split mine up into elaboration, solving, generalization (insert
> polytypes)... with trees that grow for the stages.

> If you stick to Hindley-Milner unification is very simple. But once you
> include higher-ranked types you have to keep track of the type variable
> scoping which is trickier. And then if you also want some subtyping between
> the foralls...difficult.

> this is why i just implement bidirectional typechecking and call it a day

[Generic unification](https://ro-che.info/articles/2017-06-17-generic-unification)

> The unification-fd package by wren gayle romano is the de-facto standard way to do unification in Haskell. You’d use it if you need to implement type inference for your DSL, for example.

[proof-relevant unification (thesis)](https://twitter.com/agdakx/status/1487475588462002182)

[Lambda calculus interpreter](https://cs.pomona.edu/~michael/courses/csci131f15/hw/hw04.html)

> The semantics for the lambda calculus we’ve used in class uses substitution, not environments. Let’s write an interpreter that uses substitution!

> What are the pros and cons of the two styles of evaluator we’ve written?

[Architectures for interpreters: Substitutional, denotational, big-step and small-step](https://matt.might.net/articles/writing-an-interpreter-substitution-denotational-big-step-small-step/). This was hugely helpful!!!!!

> Substitution-based interpreters model an executing program's state as a program, and they make progress by repeatedly transforming one program into another.

[From Substitution to Environments](https://papl.cs.brown.edu/2016/Interpreting_Functions.html#%28part._subst-to-env%29). Very lucid explanation!

> Though we have a working definition of functions, you may feel a slight
> unease about it. When the interpreter sees an identifier, you might have had
> a sense that it needs to “look it up”. 

> There’s another difficulty with using substitution, which is the number of
> times we traverse the source program. It would be nice to have to traverse
> only those parts of the program that are actually evaluated, and then, only
> when necessary. But substitution traverses everything—unvisited branches of
> conditionals, for instance—and forces the program to be traversed once for
> substitution and once again for interpretation.

> The intuition that addresses the first concern is to have the interpreter
> “look up” an identifier in some sort of directory. The intuition that
> addresses the second concern is to defer the substitution. Fortunately, these
> converge nicely in a way that also addresses the third. The directory records
> the intent to substitute, without actually rewriting the program source; by
> recording the intent, rather than substituting immediately, we can defer
> substitution; and the resulting data structure, which is called an
> environment, avoids the need for source-to-source rewriting and maps nicely
> to low-level machine representations. Each name association in the
> environment is called a binding.

> The intuition that addresses the first concern is to have the interpreter “look
> up” an identifier in some sort of directory. The intuition that addresses the
> second concern is to defer the substitution. Fortunately, these converge nicely
> in a way that also addresses the third. The directory records the intent to
> substitute, without actually rewriting the program source; by recording the
> intent, rather than substituting immediately, we can defer substitution; and
> the resulting data structure, which is called an environment, avoids the need
> for source-to-source rewriting and maps nicely to low-level machine
> representations. Each name association in the environment is called a binding.

> This does not mean our study of substitution was useless; to the contrary, many
> tools that work over programs—such as compilers and analyzers—use substitution.
> Just not for the purpose of evaluating it at run-time.
> 
> Observe carefully that what we are changing is the implementation strategy
> for the programming language, not the language itself.

[papl](https://papl.cs.brown.edu/). [A Data-Centric Introduction to Computing](https://dcic-world.org/). [Programming Languages: Application and Interpretation (PLAI)](https://www.plai.org/). Look like great resources!

# slides

[Functional programming languages Part I: interpreters and operational semantics](https://xavierleroy.org/mpri/2-4/semantics.pdf) [whole](https://xavierleroy.org/mpri/2-4/)

[CS-XXX: Graduate Programming Languages Lecture 14 — Efficient Lambda Interpreters](https://homes.cs.washington.edu/~djg/teachingMaterials/gpl/lectures/lec14.pdf)

[A biased history of equality in type theory](http://kodu.ut.ee/~varmo/tday-andu/chapman-slides.pdf)

[write yourself a typed functional language](https://twitter.com/phadej/status/1050396600844120065). [slides](https://t.co/nWPJKhMJ9E). [examples](https://t.co/Ipll9SAClP). [pi](https://www.andres-loeh.de/LambdaPi/).

[compilers](http://venge.net/graydon/talks/CompilerTalk-2019.pdf)

[https://arxiv.org/pdf/1905.13706v1.pdf](https://arxiv.org/pdf/1905.13706v1.pdf)

[Cubical Syntax for Extensional Equality](http://www.jonmsterling.com/pdfs/xtt-types-slides.pdf)

[On bidirectional type checking](https://www.reddit.com/r/haskell/comments/c761nl/where_to_start_learning_about_type_checking/esddwmk?utm_source=share&utm_medium=web2x). [tweet](https://twitter.com/kmett/status/1016724574359228418). [video](https://youtu.be/utyBNDj7s2w?t=2353). [notes](https://twitter.com/RanjitJhala/status/1122174628477095936).

> I love bidirectional, but it's not the best if your goal is inference in the absence of any type annotations.

[Derivations as computations](http://math.andrej.com/2019/08/21/derivations-as-computations/)

[An infinitary rewriting interpretation of coinductive types](https://arxiv.org/abs/1808.05059)

[Calculating Correct Compilers II](http://www.cs.nott.ac.uk/~pszgmh/ccc2.pdf)

[Elaborating dependent (co)pattern matching: No pattern left behind](https://www.cambridge.org/core/journals/journal-of-functional-programming/article/elaborating-dependent-copattern-matching-no-pattern-left-behind/F13CECDAB2B6200135D45452CA44A8B3)

[Effect Handlers via Generalised Continuations](http://homepages.inf.ed.ac.uk/slindley/papers/ehgc.pdf). [tweet](https://twitter.com/reifyreflect/status/1242401076722249729)

[Simply typed lambda calculus](https://splintah.gitlab.io/posts/2020-05-24-Simply-typed-lambda.html)

[An Algebraic Approach to Typechecking and Elaboration](https://twitter.com/rob_rix/status/1312853414141886464). [talk](https://bentnib.org/posts/2015-04-19-algebraic-approach-typechecking-and-elaboration.html). [slides](https://bentnib.org/docs/algebraic-typechecking-20150218.pdf).

[Refinement Types: A Tutorial](https://arxiv.org/abs/2010.07763)

> a “nanopass style” tutorial on how to implement refinement type checkers

>  we show how to implement a refinement type checker via a progression of languages that incrementally add features to the language or type system.

[elaboration-zoo](https://github.com/AndrasKovacs/elaboration-zoo). [tweet](https://twitter.com/rob_rix/status/1244394684132229128). [tweet](https://twitter.com/acid2/status/1329360234616381442). [tweet](https://twitter.com/andrasKovacs6/status/1450114071236317187).

[What makes dependent type theory more suitable than set theory for proof assistants?](https://twitter.com/andrejbauer/status/1329766186813435906)

[Calculating Programs (MGS 2019)](https://twitter.com/DiazCarrete/status/1341699853949292544)

[Reasoning about the garden of forking paths](https://twitter.com/Jose_A_Alonso/status/1373168130399297537)

[An Existential Crisis Resolved](https://richarde.dev/papers/2021/exists/exists.pdf)

[what is a type](https://twitter.com/jjcarett2/status/1373281475945185282)

[elaboration](https://github.com/facet-lang/facet/blob/condictuationary-passing-style/docs/elaboration.md). [bidirectional evaluation](https://twitter.com/jjcarett2/status/1380143242625355776).

[Calculating Dependently-Typed Compilers](https://twitter.com/haskellhutt/status/1391314934449987584)

[Counterexamples in Type Systems](http://counterexamples.org/intro.html)

[how undefined values arise In programming languages.](https://twitter.com/andrejbauer/status/1268928013472870402)

[Efficient Lambda Interpreters](https://homes.cs.washington.edu/~djg/teachingMaterials/gpl/lectures/lec14_6up.pdf)

> replace substitution with environment/closures

> Making evaluation contexts explicit data structures was key

[A Lambda Interpreter](http://lampwww.epfl.ch/teaching/archive/foundations_of_programming/2001/slides/interp.pdf)

[Row Polymorphism Isn't Subtyping](https://brianmckenna.org/blog/row_polymorphism_isnt_subtyping)

[Abstract machines and the compilers that love/hate them](https://lobste.rs/s/xngt2a/abstract_machines_compilers_love_hate)

[On the Expressive Power of Programming Languages](https://www.youtube.com/watch?v=43XaZEn2aLc)

# books

[Making uniqueness types less unique](http://edsko.net/pubs/thesis.pdf) [post](http://edsko.net/2017/01/08/linearity-in-haskell/)

[lambda calculus notes](https://www.irif.fr/~mellies/mpri/mpri-ens/biblio/Selinger-Lambda-Calculus-Notes.pdf)

[Programs and Proofs Mechanizing Mathematics with Dependent Types](http://ilyasergey.net/pnp/pnp.pdf)

[Abstraction and Computation Type Theory, Algebraic Structures, and Recursive Functions](http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.78.7246&rep=rep1&type=pdf)

[Metaprogramming Lecture Notes](https://www.cl.cam.ac.uk/~na482/meta/lecture-notes.pdf).

[A Denotational Engineering of Programming Languages](https://arxiv.org/abs/1905.01473)

[Introduction to homotopy type theory Egbert Rijke](http://www.andrew.cmu.edu/user/erijke/hott/hott_intro.pdf). [github](https://github.com/EgbertRijke/HoTT-Intro)

[J.N. OLIVEIRA PROGRAM DESIGN BY CALCULATION](http://www4.di.uminho.pt/~jno/ps/pdbc.pdf). [post](http://www.philipzucker.com/a-short-skinny-on-relations-towards-the-algebra-of-programming/?preview=true)

[Functional Algorithms, Verified](https://news.ycombinator.com/item?id=28884229)

[a semantics for your PL](https://twitter.com/ProfMaxNew/status/1517113693624020993)

    Algebras of a Monad
    Coalgebras of a Comonad
    Sheaves
    Comma categories
    Internal categories

## videos

[Curry On Talk: The Practice and Theory of TLA+](https://pron.github.io/posts/tlaplus-curryon-talk)

[Dana Scott & Jeremy Siek - Theory & Models of Lambda Calculus: Typed and Untyped (Part 1) - λC 2018 1](https://www.youtube.com/watch?v=1nkJGgHktUI). [2](https://www.youtube.com/watch?v=HNKvwTrp9zQ). [6/6](https://www.youtube.com/watch?v=6KmqkC9puI0).

[A New Language for Constant-Time Programming](https://www.youtube.com/watch?v=kbn9UCRK2Qg).

[TYPE INFERENCE FROM SCRATCH](https://www.youtube.com/watch?v=ytPAlhnAKro)

Implementing a Dependently Typed Language [1](https://www.youtube.com/watch?v=AwaZW0QQsuo&list=PLcAu_kKy-krxDD1WwRX_9rc0knAFK3nHs&index=26&t=0s) [2](https://www.youtube.com/watch?v=8Yjjo1qIk5A&list=PLcAu_kKy-krxDD1WwRX_9rc0knAFK3nHs&index=27&t=0s) [3](https://www.youtube.com/watch?v=deaZK10WjsU&list=PLcAu_kKy-krxDD1WwRX_9rc0knAFK3nHs&index=28&t=0s) [4](https://www.youtube.com/watch?v=jE3vKCqLrnM&list=PLcAu_kKy-krxDD1WwRX_9rc0knAFK3nHs&index=29&t=0s) [5](https://www.youtube.com/watch?v=4UeuBUOP4_g&list=PLcAu_kKy-krxDD1WwRX_9rc0knAFK3nHs&index=30&t=0s) [6](https://www.youtube.com/watch?v=e9FVccCkFUo&list=PLcAu_kKy-krxDD1WwRX_9rc0knAFK3nHs&index=31&t=0s) 

[starting with semantics](https://news.ycombinator.com/item?id=20486318)

[tabled typeclass resolution](https://www.reddit.com/r/haskell/comments/eqj1b5/tabled_typeclass_resolution_lean_theorem_prover/)

[Game Semantics and Session Types](https://twitter.com/bblfish/status/1229503709803143173)

[Big Step Normalisation for Type Theory](https://nottingham-repository.worktribe.com/preview/4475690/big_step_normalisation.pdf)

[Generalized Church is the Curry-Howard of Knaster-Tarski](https://youzicha.tumblr.com/post/624180258328002560/generalized-church-is-the-curry-howard-of)

[Type Inference needs Revolution (2015)](https://www.youtube.com/watch?v=ad4BVmPni7A)

[Epigram 2 - Autopsy, Obituary, Apology](https://vimeo.com/428161108)

[The Hitchhiker’s Guide to Logical Verification](https://twitter.com/Jose_A_Alonso/status/1316993638526836736)

[Replacing functions with data (defunctionalization)](https://www.youtube.com/watch?v=wppzFzzD4b8)

[Dependent Types - salvation or plague ](https://www.youtube.com/watch?v=x3y22-cMBMQ)

[Correcting A Widespread Error in Unification Algorithms](https://twitter.com/papers_we_love/status/1483775016604950528)

[Predictable Macros for Hindley-Milner](https://davidchristiansen.dk/pubs/tyde2020-predictable-macros-abstract.pdf). 

[ESOP 2022. "A Dependent Dependency Calculus"](https://twitter.com/fancytypes/status/1512005249946501125?t=j2hECKSyRKVHP9KQnwUokw&s=03)

[a golden age of PL research](https://twitter.com/k4rtik/status/1569938898981163018)

[if you put enough effort into the practice, you eventually discover entirely new problems for theory](https://twitter.com/ShriramKMurthi/status/1576047732334415872)

[operational and denotational semantics](https://twitter.com/jonmsterling/status/1580295434060238849)

[The Missing Prelude to The Little Typer's Trickiest Chapter](https://lobste.rs/s/dhpgel/missing_prelude_little_typer_s_trickiest)

[Call-by-push-value is...](https://twitter.com/ProfMaxNew/status/1584530793933643776)

> A calculus embedding CBV and CBN
> A syntax for a strong adjunction
> A metalanguage for defining abstract machines
> A typed IR extending CPS/ANF with stack manipulation

[Intrinsically-Typed Definitional à la Carte](https://twitter.com/JulesJacobs5/status/1593241199309033472)

[Hefty Algebras: Modular Elaboration of Higher-Order Algebraic Effects](https://www.reddit.com/r/haskell/comments/z1s907/hefty_algebras_modular_elaboration_of_higherorder/)

[game semantics](https://curien.galene.org/papers/Game-semantics.pdf). [Higher-orderness is first-order interaction](https://discourse.haskell.org/t/higher-orderness-is-first-order-interaction/5386).

[The Golden Age of PL Research](https://semantic-domain.blogspot.com/2022/09/the-golden-age-of-pl-research.html)

[course on Programming Language Design](https://twitter.com/tomaspetricek/status/1610028878046576644) [same](https://d3s.mff.cuni.cz/teaching/nprg075/)

[Seventy Years Using Fixed Points](https://twitter.com/ToposInstitute/status/1641189744578031616)

[lower your guards](https://twitter.com/Innf107/status/1663922920370913283)

[Compiling Functional Languages (2011)](https://www.cse.chalmers.se/edu/year/2011/course/CompFun/)

[AST vs. Bytecode: Interpreters in the Age of Meta-Compilation](https://stefan-marr.de/downloads/oopsla23-larose-et-al-ast-vs-bytecode-interpreters-in-the-age-of-meta-compilation.pdf). [hn](https://news.ycombinator.com/item?id=37119482).

> Thanks to partial evaluation and meta-tracing, it became practical to build language implementations that reach state-of-the-art peak performance by implementing only an interpreter. 

## ICFP’22 

[playlist](https://discourse.haskell.org/t/the-icfp22-playlist-has-been-published-to-youtube/5138)

## MuniHac 2022

[playlist](https://www.youtube.com/playlist?list=PLxxF72uPfQVRQXih84omWRmacz1lwejc6)

## Haskell Symposium 2022

[playlist](https://www.youtube.com/playlist?list=PLyrlk8Xaylp4zxdY-QEh_g6CHlhkAsBya)

## Haskel Love 2021

[playlist](https://www.youtube.com/playlist?list=PLBqWQH1MiwBTwo2wrwINAorzXRumxO41s)

## More stuff

[Disco: A Functional Programming Language for Discrete Mathematics](https://arxiv.org/abs/2308.06971v1)

[jits](https://twitter.com/joepolitz/status/1700182636281692490). [1](https://ucsd-compilers-s23.github.io/week2/index.html#extension-assembling-directly-from-rust). [2](https://ucsd-compilers-s23.github.io/week3/index.html#extension-using-dynamic-information-to-optimize). [3](https://ucsd-compilers-s23.github.io/week5/index.html#extension-3-compiling-functions-with-dynamically-discovered-types). [two ways of saying tomato](https://tratt.net/laurie/blog/2023/compiled_and_interpreted_languages_two_ways_of_saying_tomato.html).

[PLAI epub](https://twitter.com/krismicinski/status/1704872149758951775). [tweet](https://twitter.com/krismicinski/status/1704872149758951775).

[Programming Language Semantics It’s Easy As 1,2,3](https://www.cs.nott.ac.uk/~pszgmh/123.pdf)

[SSA is isomorphic to a functional IR](https://hachyderm.io/@maxsnew@types.pl/111218416772375704). [article](https://dl.acm.org/doi/10.1145/278283.278285).

[Cornell's CS 4110 PL theory class](https://www.cs.cornell.edu/courses/cs4110/2021fa/lectures/lecture19.pdf)

[Write your own tiny programming system(s)!](https://d3s.mff.cuni.cz/teaching/nprg077/). [Writing a Compiler is Surprisingly Easy (part 1)](https://news.ycombinator.com/item?id=38182461).

[A correct-by-construction conversion from lambda calculus to combinatory logic](https://news.ycombinator.com/item?id=38390402). [Microhaskell](https://www.youtube.com/watch?v=Zk5SJ79nOnA).

[It's too easy to lean too hard on object-language function spaces](https://hachyderm.io/@pigworker@types.pl/111688001848656137)

[I'm betting on Call-by-Push-Value](https://thunderseethe.dev/posts/bet-on-cbpv/)

[Abstracting Denotational Interpreters](https://arxiv.org/abs/2403.02778). [reddit](https://www.reddit.com/r/haskell/comments/1bbx3dq/comment/kudkh58/). [Difference Between Small and Big-step Operational Semantics](https://cs.stackexchange.com/questions/43294/difference-between-small-and-big-step-operational-semantics).

> We explore denotational interpreters: denotational semantics that produce coinductive traces of a corresponding
small-step operational semantics

> Big-step semantics are kind of in the middle [of small step and denotational semantics]. it abstracts away the details of the evaluation but retains the syntactic nature of the result. 

> Operationally speaking, small-step semantics corresponds to looking at each operation performed by an interpreter for the language. Big-step semantics only looks at the resulting value. Denotational semantics looks at a mathematical interpretation which may or may not have anything to do with what happens on a computer.

> big-step semantics are the closest possible analogues to interpreters

[Functional Big-step Semantics](https://cakeml.org/esop16.pdf). [Architectures for interpreters: Substitutional, denotational, big-step and small-step](https://matt.might.net/articles/writing-an-interpreter-substitution-denotational-big-step-small-step/). [A Meta-theory for Big-step Semantics](https://dl.acm.org/doi/abs/10.1145/3522729). [Big-step normalisation](https://www.researchgate.net/publication/220676608_Big-step_normalisation)

> A functional big-step semantics is essentially an interpreter written in a purely functional style and equipped with a clock to ensure that the function is total, even when run on diverging programs

>  It's accurate enough to say that a semantics is just an interpreter that's not allowed to use side effects. (Or, you could think of an interpreter as a semantics that's allowed to use side effects.)

[The precise definition of Normalization By Evaluation?](https://cstheory.stackexchange.com/questions/52149/the-precise-definition-of-normalization-by-evaluation). [Normalization and Partial Evaluation](http://hjemmesider.diku.dk/~andrzej/papers/NaPE.pdf)

[Why is defunctionalization good?](https://www.michaelpj.com/blog/2024/03/11/defunctionalization-thoughts.html)

[the common semantic core of many languages](https://twitter.com/ShriramKMurthi/status/1778814394304024800)

[Compiling higher order functions with GADTs](https://injuly.in/blog/defunct/)

[On the State of Coherence in the Land of Type Classes](https://arxiv.org/abs/2502.20546). [bsky](https://bsky.app/profile/cspl-bot.bsky.social/post/3ljhbrckuwp2o).

[not-provably-equal proofs of equality](https://hachyderm.io/@robinadams@mathstodon.xyz/114466453196287111)

[Typing the futamura projections](https://www.reddit.com/r/haskell/comments/1l5yzcn/typing_the_futamura_projections/)

[input-subject-output discipline](https://lipn.info/@mevenlennonbertrand/114681580607515358)

[type inference zoo](https://zoo.cuichen.cc/)





