# Recursion schemes

## papers

[Program Calculation Properties of Continuous Algebras](http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.58.7741&rep=rep1&type=pdf)

[Functional Programming with Bananas, Lenses, Envelopes and Barbed Wire](http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.41.125)

[Origami Programming](http://www.staff.science.uu.nl/~3860418/msc/11_infomtpt/papers/origami-programming_Gibbons.pdf)

[A tutorial on the universality and expressiveness of fold](http://www.cs.nott.ac.uk/~pszgmh/fold.pdf)

[Factorising Folds for Faster Functions](http://www.fceia.unr.edu.ar/~mauro/pubs/f5-ext.pdf)

[The Under-Appreciated Unfold](http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.42.1735)

[When is a function a fold or an unfold?](http://www.cs.nott.ac.uk/~pszgmh/when.pdf)

[Constructively Characterizing Fold and Unfold](http://www.cs.uwyo.edu/~jlc/papers/workshop.pdf)

[Paramorphims](http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.19.4825)

[FUNCTIONAL PROGRAMMING WITH APOMORPHISMS (CORECURSION)](http://cs.ioc.ee/~tarmo/papers/nwpt97-peas.pdf)

[Metamorphisms: Streaming Representation-Changers](http://www.cs.ox.ac.uk/people/jeremy.gibbons/publications/metamorphisms-scp.pdf)

[Primitive (Co)Recursion and Course-of-Value (Co)Iteration, Categorically](http://cs.ioc.ee/~tarmo/papers/inf.pdf)

[Histo- and Dynamorphisms Revisited](http://www.cs.ox.ac.uk/people/nicolas.wu/publications/Histomorphisms.pdf)

[Recursion Schemes for Dynamic Programming](http://kodu.ut.ee/~eugene/kabanov-vene-mpc-06.pdf)

[Sorting morphisms](http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.51.3315&rep=rep1&type=pdf)

[Sorting with Bialgebras and Distributive Laws](http://www.cs.ox.ac.uk/people/daniel.james/sorting/sorting.pdf)

[Adjoint Folds and Unfolds](http://www.cs.ox.ac.uk/ralf.hinze/SSGIP10/AdjointFolds.pdf)

[Unifying Structured Recursion Schemes](http://www.cs.ox.ac.uk/people/jeremy.gibbons/publications/urs.pdf)

> the banana-split law, an important program optimisation that replaces a double tree traversal by a single one

[Conjugate Hylomorphisms](http://www.cs.ox.ac.uk/people/jeremy.gibbons/publications/conjugate-hylos.pdf)

[Reasoning about Algebraic Data Types with Abstractions](http://arxiv.org/abs/1603.08769)

[A Translation from Attribute Grammars to Catamorphisms](http://www.staff.science.uu.nl/~jeuri101/homepage/Publications/ags.pdf)

[Attribute Grammars as Recursion Schemes over Cyclic Representations of Zippers](http://www.sciencedirect.com/science/article/pii/S1571066111000521)

[Calculating compilers](http://www.ru.nl/publish/pages/682191/meijer_e.pdf)

[Calculating correct compilers](http://www.cs.nott.ac.uk/~pszgmh/ccc.pdf)

[Calculating Certified Compilers for Non-Deterministic Languages](http://www.diku.dk/~paba/pubs/files/bahr15mpc-paper.pdf)

[Designing and Implementing Combinator Languages](http://www.staff.science.uu.nl/~swier101/Papers/1999/AFP3.pdf)

[The design of a pretty-printing library (Hughes)](http://belle.sourceforge.net/doc/hughes95design.pdf)

[A prettier printer (Wadler)](http://homepages.inf.ed.ac.uk/wadler/papers/prettier/prettier.pdf)

[Higher-Order Recursion Abstraction](https://arxiv.org/pdf/1602.05010.pdf)

[Haskell Programming with Nested Types: A Principled Approach](https://personal.cis.strath.ac.uk/neil.ghani/papers/ghani-hosc09.pdf)

[Trees that grow](https://www.microsoft.com/en-us/research/wp-content/uploads/2016/11/trees-that-grow.pdf) [Trees that shrink](https://www.reddit.com/r/haskell/comments/8s75n3/trees_that_shrink/)

[Generalised folds for nested datatypes](https://www.cs.ox.ac.uk/richard.bird/online/BirdPaterson99Generalised.pdf)

[Disciplined, efficient, generalised folds for nested datatypes](http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.16.8985&rep=rep1&type=pdf)

[Compiling Tree Transforms to Operate on Packed Representations](http://drops.dagstuhl.de/opus/volltexte/2017/7273/)

[Algorithm W Step by Step](http://catamorph.de/documents/AlgorithmW.pdf)

[Histo- and Dynamorphisms Revisited](http://www.cs.ox.ac.uk/people/nicolas.wu/publications/Histomorphisms.pdf)

[Accumulating Attributes](http://www.cs.ox.ac.uk/people/jeremy.gibbons/publications/accatt.pdf)

> I don’t know about “principled way to choose”; I think that’s largely a matter of taste. Try it both ways, and see which you prefer! More concretely, consider which properties you might like to prove of such functions; maybe those properties are more easily proved using coinduction than induction, in which case you should probably look for a coinductive program (an unfold) over an inductive one (a fold).

[Fixing Idioms](http://ilyasergey.net/papers/idioms-pepm13.pdf)

[Catamorphism-Based Program Transformations for Non-Strict Functional Languages](https://www.microsoft.com/en-us/research/wp-content/uploads/2016/07/laszlo-thesis.pdf)

[Dependently Typed Folds for Nested Data Types](https://arxiv.org/abs/1806.05230)

[Coroutining Folds with Hyperfunctions](https://arxiv.org/abs/1309.5135). [folding two things at once](https://doisinkidney.com/posts/2016-04-17-folding-two-at-once.html).

[The Under-Performing Unfold](http://www.cs.nott.ac.uk/~pszjlh/underperforming.pdf)

[General recursion via coinductive types, by Capretta (2005).](http://www.duplavis.com/venanzio/publications/Recursion_Coinductive_LMCS_2005.pdf) [Turing-completeness totally free, by McBride (2015?).](https://personal.cis.strath.ac.uk/conor.mcbride/TotallyFree.pdf) [reddit](https://www.reddit.com/r/haskell/comments/hn2ufg/tail_recursive_only_fix_point_combinator/fx9osk1/).

> Sometimes this is called a combinator for iteration as opposed to recursion, ie., loop corresponds to the imperative intuition of "do this, repeat"

> Categories with a combinator of that very type are called iteration theories

> iteration and recursion are closely related. The way I like to informally relate the two is that iteration is "just" tail recursion, and conversely, recursion can often be encoded iteratively in a stack machine. But depending on how you phrase the concepts they could be literally the same thing. That's actually what happens with iteration theories: they are models for both "iterative" languages (with loop-like constructs) and "recursive" languages (with fix-like constructs). More precisely, an iteration theory is a category with coproducts (sums of types) and a function on morphisms from a -> b + a to a -> b satisfying a bunch of equations. 

> In Haskell-speak, loop and fix correspond to two instances of the same class of iterative theories.

> Another place where loop comes up is in representing non-terminating computations in total languages, because tail recursion is closely related to the guardedness condition for coinductive definitions. That's the starting point of the paper General recursion via coinductive types, by Capretta (2005). In contrast, it's less obvious how to encode something like fix, where you're morally allowed to make recursive calls anywhere. The aforementioned paper discusses one solution in its later sections. Another one is to use a free monad, delaying the recursive calls with an effect; that's the topic of Turing-completeness totally free, by McBride (2015?).

[CATEGORICAL PROGRAMMING WITH INDUCTIVE AND COINDUCTIVE TYPES](https://kodu.ut.ee/~varmo/papers/thesis.pdf). [tweet](https://twitter.com/xgrommx/status/1280967576336695298). [The Nax Language: Unifying Functional Programming and Logical Reasoning in a Language based on Mendler-style Recursion Schemes and Term-indexed Types](https://pdxscholar.library.pdx.edu/open_access_etds/2088/)

[tail recursive only fix point combinator](https://www.reddit.com/r/haskell/comments/hn2ufg/tail_recursive_only_fix_point_combinator/fx9osk1/). [book](http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.363.3634)

> Sometimes this is called a combinator for iteration as opposed to recursion, ie., loop corresponds to the imperative intuition of "do this, repeat" (this is equivalent to forever :: m () -> m Void in the monad m = StateT t (Either p)), whereas fix corresponds to the declarative intuition of "definitions where the right-hand side mentions the left-hand side" (with "tail-recursion" adding constraints on where those mentions may occur).

> Categories with a combinator of that very type are called iteration theories, there's even a whole book on the topic: Iteration Theories: The Equational Logic of Iterative Processes, by Bloom & Esik (1993).

## blog posts

[Recursion schemes for dummies?](http://stackoverflow.com/questions/6941904/recursion-schemes-for-dummies)

[Recursion Schemes: A Field Guide](http://comonad.com/reader/2009/recursion-schemes/)

[An Introduction to Recursion Schemes](http://blog.sumtypeofway.com/an-introduction-to-recursion-schemes/)

[Recursion Schemes, Part 2: A Mob of Morphisms](http://blog.sumtypeofway.com/recursion-schemes-part-2/)

[Grokking recursion-scheme: Part 1](http://jozefg.bitbucket.org/posts/2014-05-19-like-recursion-but-cooler.html)

[Grokking recursion-scheme: Part 2](http://jozefg.bitbucket.org/posts/2014-06-14-like-recursion-but-cooler-2.html)

[Hylomorphisms in Haskell](https://ulissesaraujo.wordpress.com/2009/04/09/hylomorphisms-in-haskell/)

[More Hylomorphisms in Haskell](https://ulissesaraujo.wordpress.com/2009/04/09/more-hylomorphisms-in-haskell/)

[Category:Recursion schemes](https://en.wikipedia.org/wiki/Category:Recursion_schemes)

[Folds in context](http://blog.sumtypeofway.com/recursion-schemes-part-iii-folds-in-context/)

[Dynamorphisms as chronomorphisms](http://comonad.com/reader/2008/dynamorphisms-as-chronomorphisms/)

[Histomorphisms, Zygomorphisms and Futumorphisms specialised to lists](http://stackoverflow.com/questions/36851766/histomorphisms-zygomorphisms-and-futumorphisms-specialised-to-lists)

[Examples of histomorphisms in Haskell](http://stackoverflow.com/questions/24884475/examples-of-histomorphisms-in-haskell)

[catamorphism = iterator, paramorphism = recursor](https://www.reddit.com/r/haskell/comments/61zs2l/regarding_dsls_what_are_the_recommended_use_cases/dfk2ctn/)

[Mixing Supercompilers and Recursion Using Elgot Algebras](http://blog.vmchale.com/article/elgot) [reddit](https://www.reddit.com/r/haskell/comments/70vart/mixing_supercompilers_and_recursion_using_elgot/)

[Histomorphisms, Zygomorphisms and Futumorphisms specialised to lists](https://stackoverflow.com/questions/36851766/histomorphisms-zygomorphisms-and-futumorphisms-specialised-to-lists)

[Examples of histomorphisms in Haskell](https://stackoverflow.com/questions/24884475/examples-of-histomorphisms-in-haskell)

[Recursion Schemes, Part IV: Time is of the Essence](http://blog.sumtypeofway.com/recursion-schemes-part-iv-time-is-of-the-essence/) [reddit](https://www.reddit.com/r/haskell/comments/75pfaz/recursion_schemes_exploring_histomorphisms_and/)

[Recursion schemes using `Fix` on a data-type that's already a Functor?](https://stackoverflow.com/questions/41524960/recursion-schemes-using-fix-on-a-data-type-thats-already-a-functor)

[recursion schemes that prune](https://cstheory.stackexchange.com/questions/18374/recursion-schemes-that-prune/18399#18399)

[the digits of py - metamorphism example](https://patternsinfp.wordpress.com/2017/11/09/the-digits-of-pi/)

[A catamorphic lambda-calculus interpreter](https://www.michaelpj.com/blog/2018/04/08/catamorphic-lc-interpreter.html) [reddit](https://www.reddit.com/r/haskell/comments/8aqivp/a_catamorphic_lambdacalculus_interpreter/)

[A Simple Hylomorphism Example](https://colourcoding.net/2018/04/12/a-simple-hylomorphism-example/) [reddit](https://www.reddit.com/r/haskell/comments/8bsb67/a_simple_hylomorphism_example/)

[How to make catamorphisms work with parameterized/indexed types?](https://stackoverflow.com/questions/17503131/how-to-make-catamorphisms-work-with-parameterized-indexed-types)

[Recursion Schemes, Part V: Hello, Hylomorphisms](http://blog.sumtypeofway.com/recursion-schemes-part-v/)

[Program Reduction: A Win for Recursion Schemes](http://newartisans.com/2018/04/win-for-recursion-schemes/) [reddit](https://www.reddit.com/r/haskell/comments/8djcxq/program_reduction_a_win_for_recursion_schemes/)

[Annotating an AST with type information using `recursion-schemes`?](https://www.reddit.com/r/haskell/comments/8ed7mm/annotating_an_ast_with_type_information_using/)

[Recursion Schemes for Higher Algebras](https://bartoszmilewski.com/2018/08/20/recursion-schemes-for-higher-algebras/)

> The idea is that free constructions arise as fixed points of higher order functors, and therefore can be approached with the same algebraic machinery as recursive data structures, only at a higher level.

[Feval: F-Algebras for expression evaluation](http://www.burz.io/2014/06/15/feval.html)

[What is the difference between Fix, Mu and Nu in Ed Kmett's recursion scheme package](https://stackoverflow.com/questions/45580858/what-is-the-difference-between-fix-mu-and-nu-in-ed-kmetts-recursion-scheme-pac/45581539#45581539)

[Recursion Schemes, Part VI: Comonads, Composition, and Generality](https://blog.sumtypeofway.com/recursion-schemes-part-6-comonads-composition-and-generality/). [reddit](https://www.reddit.com/r/haskell/comments/avrjkb/recursion_schemes_part_6_comonads_composition_and/). also an [interesting discussion](https://github.com/ekmett/recursion-schemes/pull/51) in a github issue.

[A natural way to fold over the history involved in a histomorphism?](https://www.reddit.com/r/haskell/comments/az4w8e/a_natural_way_to_fold_over_the_history_involved/)

[Compdata Trees and Catamorphisms](https://blaxill.org/posts/compdata-trees-and-catamorphisms/).

[adjoint folds and unfolds](http://www.cs.ox.ac.uk/ralf.hinze/SSGIP10/AdjointFolds.pdf)

[over nested datatypes: still hard](https://twitter.com/importantshock/status/1144312128343613447)

[Stream Fusion From Lists to Streams to Nothing at All](http://fun.cs.tufts.edu/stream-fusion.pdf) [mentioned here](https://free.cofree.io/2020/05/06/string-types/). [and here](http://pesquisa.ufabc.edu.br/haskell/posts/categorias/14-Yoneda.html). [on hackage](http://hackage.haskell.org/package/stream-fusion-0.1.2.5)

> there are at least two ways to turn a Haskell list into functions, and they are related in an interesting way:
> Representing the list inductively (a.k.a. build/foldr fusion system):
> Representing the list coinductively (a.k.a. stream fusion)

[rs for asts tweet](https://twitter.com/smdiehl/status/1259014458569117698)

[multiplate](https://www.reddit.com/r/haskell/comments/i2js6q/lenses_for_tree_traversals/g0a6j1q?utm_source=share&utm_medium=web2x)

[A Hierarchy of Mendler style iteration/recursion combinators](http://www.cs.nott.ac.uk/~psxld/seminars/seminar_slides/kya_seminar.pdf). [tweet](https://twitter.com/sarah_zrf/status/1296487943855583233).

[the standard catamorphism [...] can specialize to a monadic carrier type](https://twitter.com/importantshock/status/1359871984469999619)

[Combining folds using semigroups](https://luctielen.com/posts/combining_folds_using_semigroups/)

[recursion schemes in the GRIN compiler](https://github.com/grin-compiler/grin/#simplifying-transformations)

[Composing non-distributive monads in recursion-schemes](https://stackoverflow.com/questions/67925608/composing-non-distributive-monads-in-recursion-schemes)

[a Clowns to the Left of Me, Jokers to the Right–inspired CK machine and an NbE-inspired catamorphic evaluator](https://twitter.com/rob_rix/status/1416486320931807244)

[co-functions (aka coexponentials, coimplicatives, subtractions)](https://twitter.com/rob_rix/status/1423144446997192704?s=03).

[hyperfunctions and streams](https://twitter.com/noaheasterly/status/1388834721619189760). 

[repository of recursion schemes applied to practical algorithms](https://twitter.com/tangled_zans/status/1426149649635807236).

[what’s your favourite way to represent syntax trees annotated with source ranges](https://twitter.com/rob_rix/status/1431947253611208706)

[Recursion Schemes for Higher Algebras](https://bartoszmilewski.com/2018/08/20/recursion-schemes-for-higher-algebras/)

[Create recursion schemes using comonads](https://www.reddit.com/r/haskell/comments/u7t2j9/create_recursion_schemes_using_comonads/). [How to lower an IR](https://www.reddit.com/r/haskell/comments/urutbu/how_to_lower_an_ir/)

[recursion schemes chart](https://twitter.com/bgavran3/status/1527420799950503971)

[Alpha Beta Pruning with Recursion Schemes](https://stackoverflow.com/questions/72517172/alpha-beta-pruning-with-recursion-schemes)

[Elegant and performant recursion in Rust](https://lobste.rs/s/xfmbxf/elegant_performant_recursion_rust)

[hylomorphism in Rust](https://twitter.com/inanna_malick/status/1577701421704544257)

[Defining a custom recursion scheme to manipulate two mutually-recursive types, in the context of a toy bidirectional type checker](https://twitter.com/haskell_cat/status/1586567576741617664)

[uniplate is a traversal](https://www.reddit.com/r/haskell/comments/ylrab9/uniplate_is_a_traversal/)

[indexed recursion schemes](https://www.reddit.com/r/haskell/comments/13vv6ns/indexed_recursion_schemes_or_finding_your_way/)

[Ergonomic folds: generics-sop recursion schemes, without "base functor"](https://www.reddit.com/r/haskell/comments/1axa7sq/ergonomic_folds_genericssop_recursion_schemes/)

## videos

[Unifying Structured Recursion Schemes](https://www.youtube.com/watch?v=9EGYSb9vov8)

[Recursion Schemes](https://www.youtube.com/watch?v=9EGYSb9vov8)

[calculating correct compilers](https://www.reddit.com/r/haskell/comments/56l8cs/calculating_correct_compilers_skillscast/)

[London Haskell Recursion Schemes](https://www.youtube.com/watch?v=Zw9KeP3OzpU)

[Lazily Diffing Merkle Trees with Recursion Schemes](https://www.youtube.com/watch?v=o7sUMwR1Q-M&list=PLcAu_kKy-krxDD1WwRX_9rc0knAFK3nHs)

[A tail recursive machine for the untyped lambda calculus, derived purely mechanically from the naive version by defunctionalization](https://twitter.com/paf31/status/1416041653144457216).

[Structured Traversals for (Mutually) Recursive Algebraic Data Types](https://www.youtube.com/watch?v=Xk_inDd0Pgk&t=1s)

[Language-Integrated Recursive Queries](https://bsky.app/profile/cspl-bot.bsky.social/post/3llxqfhoh4k2s). [arxiv](https://arxiv.org/abs/2504.02443).

## software

[recursion-schemes](http://hackage.haskell.org/package/recursion-schemes). [recursion-schemes-5.1](https://twitter.com/haskell_cat/status/1073935341944537089).

> transverse is a version of hoist with side-effects. This time we cannot specialize hoist, we really do need a dedicated function

[Hnix](https://www.reddit.com/r/haskell/comments/nstig5/hnix_nix_in_haskell_about_the_project_meeting/)

[jet cli - structural json editor](https://www.reddit.com/r/haskell/comments/r4ec10/jet_cli_structural_editor_for_json/)

